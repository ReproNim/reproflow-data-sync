import json
import sys
from enum import Enum
from pathlib import Path

from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional, List, Generator, Tuple
import jsonlines
import pandas as pd
import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# placeholder for common timing code in ReproNim projects

# common functions

def dump_csv(lst: List):
    # Convert the list of Pydantic models or objects to a DataFrame
    df = pd.DataFrame([obj.dict() for obj in lst])
    # Print the DataFrame as CSV to stdout
    df.to_csv(sys.stdout, index=False)


def dump_jsonl(obj):
    if obj:
        if isinstance(obj, BaseModel):
            print(obj.model_dump_json())
        else:
            print(json.dumps(obj, ensure_ascii=False))


def find_study_range(dump_dicoms_path: str) -> Tuple[Optional[datetime], Optional[datetime]]:
    with (jsonlines.open(dump_dicoms_path) as reader):
        for obj in reader:
            if obj.get('type') == 'StudyRecord' and obj.get('name') == 'dbic^QA':
                res = pd.to_datetime(obj['range_isotime_start']), pd.to_datetime(obj['range_isotime_end'])
                return res;
        return None, None


_last_id: dict = {
    "birch": 0,
    "dicoms": 0,
    "mark": 0,
    "psychopy": 0,
    "reproevents": 0,
    "qrinfo": 0,
    "series": 0,
    "study": 0,
}
def generate_id(name: str) -> str:
    # generate unique id based on int sequence
    global _last_id
    _last_id[name] += 1
    return f"{name}-{_last_id[name]:06d}"


def get_session_id(path: str) -> str:
    # extract session id from path
    return Path(path).name


def parse_jsonl_gen(path: str) -> Generator[dict, None, None]:
    with jsonlines.open(path) as reader:
        for obj in reader:
            yield obj


def parse_jsonl(path: str) -> List:
    return [obj for obj in parse_jsonl_gen(path)]


def parse_isotime(v: str) -> datetime:
    if not v:
        return None
    ts = pd.to_datetime(v)
    if ts.tzinfo is not None:
        ts = ts.tz_convert('America/New_York')
    isotime = ts.tz_localize(None)
    return isotime


def str_isotime(v: datetime) -> str:
    if not v:
        return None
    return v.strftime("%Y-%m-%dT%H:%M:%S.%f")


# define ReproNim clocks
class Clock(str, Enum):
    ISOTIME = "isotime"   # Reference NTP clock
    BIRCH = "birch"       # Birch clock
    DICOMS = "dicoms"     # DICOMs clock
    PSYCHOPY = "psychopy" # psychopy clock
    QRINFO = "qrinfo"     # QRInfo clock
    REPROEVENTS = "reproevents"  # ReproEvents clock
    # ReproStim video clock, by now the same as QRInfo clock
    REPROSTIM_VIDEO = "reprostim_video"


# Define period data model
class TPeriodData(BaseModel):
    key: Optional[str] = Field(None, description="Unique tmap key "
                                                  "for back reference")
    duration: Optional[float] = Field(
        0.0, description="Reference period duration in seconds")
    deviation: Optional[float] = Field(
        1.0, description="Reference period deviation related to master clock")
    dicoms_duration: Optional[float] = Field(
        0.0, description="DICOMs period duration in seconds")
    dicoms_deviation: Optional[float] = Field(
        1.0, description="DICOMs period deviation related to master clock")
    dicoms_valid: Optional[bool] = Field(
        False, description="Specified DICOMs is valid and corresponds "
                           "to expected deviations")


# Define abstract timing map model
class TMapRecord(BaseModel):
    isotime: Optional[datetime] = Field(
        None, description="Reference time bound to NTP in isotime format")
    duration: Optional[float] = Field(
        None, description="Reference duration of the mark in seconds")
    session_id: Optional[str] = Field(
        None, description="Unique session identifier generated by "
                          "collect_data.sh script, e.g. ses-20240528")
    mark_id: Optional[str] = Field(
        None, description="Unique mark identifier across session only, "
                          "e.g. mark_000025")
    mark_name: Optional[str] = Field(
        None, description="Optional name or description of the mark")
    dicoms_id: Optional[str] = Field(
        None, description="DICOMs dump unique identifier, e.g. dicoms-000025")
    dicoms_isotime: Optional[datetime] = Field(
        None, description="Corresponding DICOMs clock time in isotime format")
    dicoms_offset: Optional[float] = Field(
        0.0, description="DICOMs offset in seconds from isotime")
    dicoms_duration: Optional[float] = Field(
        None, description="Duration measured in DICOMs clock in seconds")
    dicoms_deviation: Optional[float] = Field(
        0.0, description="Represents DICOMs time deviation ratio comparing "
                         "to master clock")
    birch_id: Optional[str] = Field(
        None, description="Birch dump identifier, e.g. birch-000027")
    birch_isotime: Optional[datetime] = Field(
        None, description="Corresponding birch clock time in isotime format")
    birch_offset: Optional[float] = Field(
        0.0, description="birch offset in seconds from isotime")
    birch_duration: Optional[float] = Field(
        None, description="Duration measured in Birch clock in seconds")
    birch_deviation: Optional[float] = Field(
        0.0, description="Represents birch time deviation ratio comparing "
                         "to master clock")
    psychopy_id: Optional[str] = Field(
        None, description="Psychopy dump identifier, e.g. psychopy-000017")
    psychopy_isotime: Optional[datetime] = Field(
        None, description="Corresponding psychopy clock time in isotime format")
    psychopy_offset: Optional[float] = Field(
        0.0, description="psychopy offset in seconds from isotime")
    psychopy_duration: Optional[float] = Field(
        None, description="Duration measured in psychopy clock in seconds")
    psychopy_deviation: Optional[float] = Field(
        0.0, description="Represents psychopy time deviation ratio "
                         "comparing to master clock")
    reproevents_id: Optional[str] = Field(
        None, description="ReproEvents dump identifier, e.g. reproevents-000012")
    reproevents_isotime: Optional[datetime] = Field(
        None, description="Corresponding ReproEvents clock time in isotime format")
    reproevents_offset: Optional[float] = Field(
        0.0, description="ReproEvents offset in seconds from isotime")
    reproevents_duration: Optional[float] = Field(
        None, description="Duration measured in ReproEvents clock in seconds")
    reproevents_deviation: Optional[float] = Field(
        0.0, description="Represents ReproEvents time deviation ratio "
                         "comparing to master clock")
    qrinfo_id: Optional[str] = Field(
        None, description="QRInfo dump identifier, e.g. qrinfo-000125")
    reprostim_video_isotime: Optional[datetime] = Field(
        None, description="Corresponding ReproStim video clock time in "
                          "isotime format")
    reprostim_video_offset: Optional[float] = Field(
        0.0, description="ReproStim video offset in seconds from isotime")
    reprostim_video_duration: Optional[float] = Field(
        None, description="Duration measured in ReproStim video clock in seconds")
    reprostim_video_deviation: Optional[float] = Field(
        0.0, description="Represents ReproStim video time deviation ratio "
                         "comparing to master clock")


# find tmap offset by clock
def get_tmap_offset(clock: Clock, tmap: TMapRecord) -> float:
    if clock == Clock.ISOTIME:
        return 0.0
    if clock == Clock.BIRCH:
        return tmap.birch_offset
    elif clock == Clock.DICOMS:
        return tmap.dicoms_offset
    elif clock == Clock.PSYCHOPY:
        return tmap.psychopy_offset
    elif clock == Clock.QRINFO:
        return tmap.reprostim_video_offset
    elif clock == Clock.REPROEVENTS:
        return tmap.reproevents_offset
    elif clock == Clock.REPROSTIM_VIDEO:
        return tmap.reprostim_video_offset
    else:
        raise ValueError(f"Unknown clock: {clock}")


# find tmap isotime by clock
def get_tmap_isotime(clock: Clock, tmap: TMapRecord) -> datetime:
    if clock == Clock.ISOTIME:
        return tmap.isotime
    if clock == Clock.BIRCH:
        return tmap.birch_isotime
    elif clock == Clock.DICOMS:
        return tmap.dicoms_isotime
    elif clock == Clock.PSYCHOPY:
        return tmap.psychopy_isotime
    elif clock == Clock.QRINFO:
        return tmap.reprostim_video_isotime
    elif clock == Clock.REPROEVENTS:
        return tmap.reproevents_isotime
    elif clock == Clock.REPROSTIM_VIDEO:
        return tmap.reprostim_video_isotime
    else:
        raise ValueError(f"Unknown clock: {clock}")


# find tmap deviation by clock
def get_tmap_deviation(clock: Clock, tmap: TMapRecord) -> float:
    if clock == Clock.ISOTIME:
        return 1.0
    if clock == Clock.BIRCH:
        return tmap.birch_deviation
    elif clock == Clock.DICOMS:
        return tmap.dicoms_deviation
    elif clock == Clock.PSYCHOPY:
        return tmap.psychopy_deviation
    elif clock == Clock.QRINFO:
        return tmap.reprostim_video_deviation
    elif clock == Clock.REPROEVENTS:
        return tmap.reproevents_deviation
    elif clock == Clock.REPROSTIM_VIDEO:
        return tmap.reprostim_video_deviation
    else:
        raise ValueError(f"Unknown clock: {clock}")


# get tmap unique key
def get_tmap_key(tmap: TMapRecord) -> str:
    return f"{tmap.session_id}|{tmap.mark_id}"


# Define ReproNim timing map service
class TMapService:
    def __init__(self, path_or_marks: str | List = None):
        self.marks = []
        self.periods = {}
        self.avg_period = TPeriodData()
        self._force_offset = {}
        if path_or_marks:
            self.load(path_or_marks)

    # adjust clock offset using correction
    def adjust_offset(self, offset: float,
                      clock: Clock,
                      dt: datetime,
                      tmap: TMapRecord) -> float:
        # limit to DICOMs clock only atm
        if clock!=Clock.DICOMS:
            return offset

        # skip correction when offset manually is specified/hardcoded
        if self._force_offset.get(clock.value) is not None:
            return offset

        tp: TPeriodData = self.get_period(tmap)
        if not tp:
            logger.debug("use avg period")
            tp = self.avg_period

        # for invalid periods use average deviation
        # but in future this can be tuned up on demand
        if not tp.dicoms_valid:
            logger.debug("use avg period instead of invalid one")
            tp = self.avg_period

        # delta sec
        d: float = (dt - tmap.isotime).total_seconds()
        correction: float = d * tp.dicoms_deviation - d
        adjusted_offset: float = offset + correction
        return adjusted_offset

    # calculate inter-series periods based on sequential
    # and sorted marks data
    def calc_periods(self):
        ap: TPeriodData = TPeriodData(valid = True,
                                      duration=0.0,
                                      deviation=1.0,
                                      dicoms_duration=0.0,
                                      dicoms_deviation=1.0,
                                      dicoms_valid = True)
        prev_mark: TMapRecord = None
        for mark in self.marks:
            if prev_mark:
                tp: TPeriodData = TPeriodData()
                tp.key = get_tmap_key(prev_mark)
                tp.duration = (mark.isotime - prev_mark.isotime).total_seconds()
                tp.deviation = 1.0
                tp.dicoms_duration = (mark.dicoms_isotime -
                                      prev_mark.dicoms_isotime).total_seconds()
                if tp.duration and tp.duration!=0:
                    tp.dicoms_deviation = tp.dicoms_duration/tp.duration
                expected_offset: float = (prev_mark.dicoms_offset +
                                          tp.duration * tp.dicoms_deviation -
                                          tp.dicoms_duration)
                offset_diff: float = expected_offset-mark.dicoms_offset
                # detected clock correction, mark period as invalid
                # tune this 30 sec interval later
                tp.dicoms_valid = True if abs(offset_diff) < 30.0 else False
                # logger.debug(f"expected_offset={expected_offset} / real={mark.dicoms_offset}, diff={offset_diff}, duration={tp.duration}, delta={tp.duration * tp.dicoms_deviation}")
                # logger.debug(f"DELTA = {1000*(tp.dicoms_deviation-mark.dicoms_deviation)}")
                self.periods[tp.key] = tp

                # for valid periods calculate global average deviation
                # where each valid deviation added proportionally to the
                # period duration
                if tp.dicoms_valid:
                    ap.duration += tp.duration
                    ap.dicoms_duration += tp.dicoms_duration;
                    ap.dicoms_deviation += (tp.dicoms_duration/100)*tp.dicoms_deviation

            prev_mark = mark

        if ap.dicoms_duration!=0:
            ap.dicoms_deviation /= ap.dicoms_duration / 100
        ap.duration = round(ap.duration, 1)
        ap.dicoms_duration = round(ap.dicoms_duration, 1)
        self.avg_period = ap

    # convert datetime from one ReproNim clock to another
    def convert(self,
                from_clock: Clock,
                to_clock: Clock,
                from_dt: datetime) -> datetime:
        # bypass conversion if clocks are the same
        if from_clock == to_clock:
            return from_dt

        # skip empty datetime
        if not from_dt:
            return None

        tmap: TMapRecord = self.find_tmap(from_clock, from_dt)
        # bypass conversion if tmap is not found
        if tmap is None:
            logger.warning(f"tmap not found for {from_dt}")
            return from_dt

        # calculate offset
        from_offset: float = self.get_offset(from_clock, tmap)
        from_offset = self.adjust_offset(from_offset,
                                         from_clock, from_dt, tmap)
        to_offset: float = self.get_offset(to_clock, tmap)
        to_offset = self.adjust_offset(to_offset, to_clock,
                                       from_dt, tmap)
        logger.debug(f"from_offset={from_offset}, to_offset={to_offset}")
        offset: float = to_offset - from_offset
        logger.debug(f"offset={offset}")

        return from_dt + pd.Timedelta(offset, unit='s')

    # for debug purposes report tmap table, calculated periods and
    # global average periods if any
    def dump_periods(self):
        for i, m in enumerate(self.marks):
            p: TPeriodData = self.get_period(m)
            logger.info(f"[{i:03}] mark   : {m.model_dump_json()}")
            logger.info(f"[{i:03}] period : {p.model_dump_json() if p else None}")
        logger.info(f"avg period   : {self.avg_period.model_dump_json()}")

    # find tmap record by datetime and clock in sorted
    # list of marks
    def find_tmap(self, clock: Clock, dt: datetime) -> TMapRecord:
        if not self.marks or len(self.marks) == 0:
            return None
        if len(self.marks) == 1:
            return self.marks[0]

        last_mark = self.marks[0]

        for mark in self.marks:
            # lookup based on provided clock using appropriate
            # ***_isotime field
            if get_tmap_isotime(clock, mark) > dt:
                break
            last_mark = mark
        return last_mark

    # force offset for certain clock
    def force_offset(self, clock: str, offset: float):
        if offset is None:
            if clock in self._force_offset:
                del self._force_offset[clock]
        else:
            logger.debug("forcing offset for %s: %f", clock, offset)
            self._force_offset[clock] = offset

    # override clock offset if any
    def get_offset(self, clock: Clock, tmap: TMapRecord) -> float:
        if self._force_offset.get(clock.value) is not None:
            logger.debug("overriding offset for %s: %f",
                         clock,
                         self._force_offset[clock.value])
            return self._force_offset[clock.value]
        return get_tmap_offset(clock, tmap)

    # get period by tmap/mark
    def get_period(self, tmap: TMapRecord) -> TPeriodData:
        key: str = get_tmap_key(tmap)
        return self.periods.get(key)

    # load marks from file
    def load(self, path_or_marks: str | List):
        if isinstance(path_or_marks, str):
            for obj in parse_jsonl_gen(path_or_marks):
                self.marks.append(TMapRecord(**obj))
        else:
            for obj in path_or_marks:
                self.marks.append(TMapRecord(**obj))

        # sort by isotime
        self.marks.sort(key=lambda x: x.isotime)
        self.calc_periods()

    def to_label(self) -> str:
        # dump number of marks and each mark in format [N]=isotime
        if len(self.marks) == 0:
            return "TMap is empty"
        return f"TMap marks count {len(self.marks)} : " \
               + ", ".join([f"[{i}]={str_isotime(mark.isotime)}" for i, mark in enumerate(self.marks)])


_tmap_svc: TMapService = None

def get_tmap_svc() -> TMapService:
    global _tmap_svc
    if not _tmap_svc:
        path_tmap: str = str(Path(__file__).with_name("repronim_tmap.jsonl"))
        logger.info(f"Loading tmap  : {path_tmap}")
        _tmap_svc = TMapService(path_or_marks=path_tmap)
        logger.info(f"              : {get_tmap_svc().to_label()}")
    return _tmap_svc
